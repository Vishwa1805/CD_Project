#include <stdio.h>
#include <stdlib.h>
#include "ast.h"
#include "engine.h" // Provides process_regex_to_dfa_dot

// External declarations from Yacc
extern int regexparse();
extern FILE* regexin;
extern ASTNode* ast_root;

// --- AST Helper Functions ---

ASTNode* create_char_node(char data) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    if (node == NULL) { fprintf(stderr, "FATAL ERROR: malloc failed in create_char_node!\n"); return NULL; }
    node->type = NODE_CHAR; node->data = data; node->left = NULL; node->right = NULL;
    return node;
}

ASTNode* create_op_node(NodeType type, ASTNode* left, ASTNode* right) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    if (node == NULL) { fprintf(stderr, "FATAL ERROR: malloc failed in create_op_node!\n"); return NULL; }
    node->type = type; node->data = 0; node->left = left; node->right = right;
    return node;
}

void free_ast(ASTNode* node) {
    if (!node) {
        return;
    }
    free_ast(node->left);
    free_ast(node->right);
    free(node);
}

// --- ** NEW FUNCTION: print_ast IMPLEMENTATION ** ---
// Helper function to print indentation
void print_indent(int level) {
    for (int i = 0; i < level; ++i) {
        fprintf(stderr, "  ");
    }
}

// Recursive function to print the AST structure to stderr
void print_ast_recursive(ASTNode* node, int level) {
    if (!node) {
        print_indent(level);
        fprintf(stderr, "(NULL)\n");
        return;
    }

    print_indent(level);
    switch (node->type) {
        case NODE_CHAR:
            fprintf(stderr, "CHAR('%c')\n", node->data);
            break;
        case NODE_STAR:
            fprintf(stderr, "STAR (*)\n");
            print_ast_recursive(node->left, level + 1);
            break;
        case NODE_PLUS:
            fprintf(stderr, "PLUS (+)\n");
            print_ast_recursive(node->left, level + 1);
            break;
        case NODE_UNION:
            fprintf(stderr, "UNION (|)\n");
            print_ast_recursive(node->left, level + 1);
            print_ast_recursive(node->right, level + 1);
            break;
        case NODE_CONCAT:
            fprintf(stderr, "CONCAT (.)\n");
            print_ast_recursive(node->left, level + 1);
            print_ast_recursive(node->right, level + 1);
            break;
        default:
            fprintf(stderr, "UNKNOWN TYPE (%d)\n", node->type);
            break;
    }
}

// Public function to start printing
void print_ast(ASTNode* root) {
    fprintf(stderr, "\n--- Abstract Syntax Tree (AST) ---\n");
    if (!root) {
        fprintf(stderr, "(Tree is NULL)\n");
    } else {
        print_ast_recursive(root, 0);
    }
    fprintf(stderr, "--- End of AST ---\n\n");
}
// --- ** END OF NEW FUNCTION ** ---


// --- Main Function ---
int main(int argc, char **argv) {
    fprintf(stderr, "--- RUNNING NEW 'regex_visualizer.exe' (V5 - with AST print) ---\n");

    regexin = stdin;
    do {
        // Run the parser generated by Bison
        // This will build the tree in 'ast_root'
        regexparse();
    } while (!feof(regexin));

    if (ast_root) {
        // ** ADDED CALL TO PRINT THE AST **
        print_ast(ast_root); // Print the tree structure before processing

        // Now, process the tree to generate DFA
        process_regex_to_dfa_dot(ast_root);
        free_ast(ast_root);
    } else {
        fprintf(stderr, "Failed to parse regex OR AST creation failed\n");
        printf("{\"error\": \"Failed to parse regex or create AST\"}\n");
        return 1;
    }
    return 0;
}

